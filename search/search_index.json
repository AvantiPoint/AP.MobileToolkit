{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AvantiPoint Mobile Toolkit \u00b6 The AvantiPoint Mobile Toolkit is built for producing Enterprise Quality applications. The Toolkit is broken into smaller chunks that are largely platform independent. Build Status \u00b6 Project Build Status AP.MobileToolkit AP.MobileToolkit.Fonts NuGet \u00b6 You can add the MyGet CI feed to nuget by adding it as a source in Visual Studio: https://www.myget.org/F/apmobiletoolkit/api/v3/index.json Tools \u00b6 Package NuGet MyGet AP.MobileToolkit.FontGenerator Cross Platform \u00b6 Package NuGet MyGet AP.CrossPlatform.Auth AP.CrossPlatform.Core AP.MobileToolkit.AAD AP.MobileToolkit.Http AP.MobileToolkit.Modularity AP.MobileToolkit.Resources AP.MobileToolkit.RxUI Xamarin.Forms \u00b6 Package NuGet MyGet AP.MobileToolkit.Forms AP.MobileToolkit.Forms.Mvvm AP.MobileToolkit.Forms.Fonts AP.MobileToolkit.Forms.Fonts.FontAwesomeFree.Brands AP.MobileToolkit.Forms.Fonts.FontAwesomeFree.Regular AP.MobileToolkit.Forms.Fonts.FontAwesomeFree.Solid","title":"Home"},{"location":"#avantipoint-mobile-toolkit","text":"The AvantiPoint Mobile Toolkit is built for producing Enterprise Quality applications. The Toolkit is broken into smaller chunks that are largely platform independent.","title":"AvantiPoint Mobile Toolkit"},{"location":"#build-status","text":"Project Build Status AP.MobileToolkit AP.MobileToolkit.Fonts","title":"Build Status"},{"location":"#nuget","text":"You can add the MyGet CI feed to nuget by adding it as a source in Visual Studio: https://www.myget.org/F/apmobiletoolkit/api/v3/index.json","title":"NuGet"},{"location":"#tools","text":"Package NuGet MyGet AP.MobileToolkit.FontGenerator","title":"Tools"},{"location":"#cross-platform","text":"Package NuGet MyGet AP.CrossPlatform.Auth AP.CrossPlatform.Core AP.MobileToolkit.AAD AP.MobileToolkit.Http AP.MobileToolkit.Modularity AP.MobileToolkit.Resources AP.MobileToolkit.RxUI","title":"Cross Platform"},{"location":"#xamarinforms","text":"Package NuGet MyGet AP.MobileToolkit.Forms AP.MobileToolkit.Forms.Mvvm AP.MobileToolkit.Forms.Fonts AP.MobileToolkit.Forms.Fonts.FontAwesomeFree.Brands AP.MobileToolkit.Forms.Fonts.FontAwesomeFree.Regular AP.MobileToolkit.Forms.Fonts.FontAwesomeFree.Solid","title":"Xamarin.Forms"},{"location":"aad/","text":"AP.MobileToolkit.AAD \u00b6 The AAD package provides an easy to use wrapper for the MSAL library and works with both Azure Active Directory and Azure Active Directory B2C. Getting Started \u00b6 To start you'll need to implement some options. The fastest way is to use the IB2COptions or IAADOptions. public class B2COptions : IB2COptions { public string Tenant => Secrets . AADTenant ; public string ClientId => Secrets . AADClientId ; public LogLevel ? LogLevel => Microsoft . Identity . Client . LogLevel . Error ; } Now that you've added your options you can create Authentication Service by using the MsalHelper : var authService = MsalHelper . CreateB2C < B2COptions >(); var authResult = await authService . LoginAsync (); if ( authResult . Success ) { // Do Something... } else { // Do Something Else... } Why use the AAD Package \u00b6 If you've looked at the MSAL Docs... they're confusing to say the least. The AAD Package greatly simplifies what you need to do to successfully use MSAL correctly. It is also built with a proper understanding of best practices to minimize authentications against the AD Tenant which can reduce your costs and improve user performance since you're reducing Http calls.","title":"Azure Active Directory"},{"location":"aad/#apmobiletoolkitaad","text":"The AAD package provides an easy to use wrapper for the MSAL library and works with both Azure Active Directory and Azure Active Directory B2C.","title":"AP.MobileToolkit.AAD"},{"location":"aad/#getting-started","text":"To start you'll need to implement some options. The fastest way is to use the IB2COptions or IAADOptions. public class B2COptions : IB2COptions { public string Tenant => Secrets . AADTenant ; public string ClientId => Secrets . AADClientId ; public LogLevel ? LogLevel => Microsoft . Identity . Client . LogLevel . Error ; } Now that you've added your options you can create Authentication Service by using the MsalHelper : var authService = MsalHelper . CreateB2C < B2COptions >(); var authResult = await authService . LoginAsync (); if ( authResult . Success ) { // Do Something... } else { // Do Something Else... }","title":"Getting Started"},{"location":"aad/#why-use-the-aad-package","text":"If you've looked at the MSAL Docs... they're confusing to say the least. The AAD Package greatly simplifies what you need to do to successfully use MSAL correctly. It is also built with a proper understanding of best practices to minimize authentications against the AD Tenant which can reduce your costs and improve user performance since you're reducing Http calls.","title":"Why use the AAD Package"},{"location":"auth/","text":"AP.CrossPlatform.Auth \u00b6 The Auth package is a lightweight Authentication abstraction layer. This includes a reference to Prism.Core and provides some base events that can be used by the Prism EventAggregator. This is largely meant to help when dealing with a JWT and you need to be able to see the claims of your user contained in the JWT. Let's assume you had the following JWT: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwiZ2l2ZW5fbmFt ZSI6IkpvaG4iLCJmYW1pbHlfbmFtZSI6IkRvZSIsIm9pZCI6IjdkOTU5NGUyLTZmMGUtNDI4NS05N DkzLWUyYzRlY2Y4OThlMiIsImVtYWlscyI6WyJqb2huLmRvZUBnbWFpbC5jb20iXSwiaWF0IjoxNT E2MjM5MDIyLCJhdXRoX3RpbWUiOjE1MTYyMzkwMjIsIm5iZiI6MTUxNjIzOTAyMiwibmV3VXNlciI 6ZmFsc2V9.ysgzPbgqvQr4pY-C3PD-wDEI7yd6evWjeGfi8KcvkYQ In the Payload of the JWT we would see the following: { \"sub\" : \"1234567890\" , \"given_name\" : \"John\" , \"family_name\" : \"Doe\" , \"oid\" : \"7d9594e2-6f0e-4285-9493-e2c4ecf898e2\" , \"emails\" : [ \"john.doe@gmail.com\" ], \"iat\" : 1516239022 , \"auth_time\" : 1516239022 , \"nbf\" : 1516239022 , \"newUser\" : false } We can easily parse the JWT and get the user claims provided like: var user = new JwtUser ( jwt ); Name = $\"{user.FirstName} {user.LastName}\" ; OnBoardUser = user . IsNew ; More Reading \u00b6 For more information be sure to check out the Azure Active Directory support via the MSAL library: MSAL Support","title":"Auth"},{"location":"auth/#apcrossplatformauth","text":"The Auth package is a lightweight Authentication abstraction layer. This includes a reference to Prism.Core and provides some base events that can be used by the Prism EventAggregator. This is largely meant to help when dealing with a JWT and you need to be able to see the claims of your user contained in the JWT. Let's assume you had the following JWT: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwiZ2l2ZW5fbmFt ZSI6IkpvaG4iLCJmYW1pbHlfbmFtZSI6IkRvZSIsIm9pZCI6IjdkOTU5NGUyLTZmMGUtNDI4NS05N DkzLWUyYzRlY2Y4OThlMiIsImVtYWlscyI6WyJqb2huLmRvZUBnbWFpbC5jb20iXSwiaWF0IjoxNT E2MjM5MDIyLCJhdXRoX3RpbWUiOjE1MTYyMzkwMjIsIm5iZiI6MTUxNjIzOTAyMiwibmV3VXNlciI 6ZmFsc2V9.ysgzPbgqvQr4pY-C3PD-wDEI7yd6evWjeGfi8KcvkYQ In the Payload of the JWT we would see the following: { \"sub\" : \"1234567890\" , \"given_name\" : \"John\" , \"family_name\" : \"Doe\" , \"oid\" : \"7d9594e2-6f0e-4285-9493-e2c4ecf898e2\" , \"emails\" : [ \"john.doe@gmail.com\" ], \"iat\" : 1516239022 , \"auth_time\" : 1516239022 , \"nbf\" : 1516239022 , \"newUser\" : false } We can easily parse the JWT and get the user claims provided like: var user = new JwtUser ( jwt ); Name = $\"{user.FirstName} {user.LastName}\" ; OnBoardUser = user . IsNew ;","title":"AP.CrossPlatform.Auth"},{"location":"auth/#more-reading","text":"For more information be sure to check out the Azure Active Directory support via the MSAL library: MSAL Support","title":"More Reading"},{"location":"http/","text":"AP.MobileToolkit.Http \u00b6 The Http package includes a lightweight API Client that makes integrating with a custom backend a breeze. You simply need to provide the base options for where the API Client should send it's requests to along with a callback handler to provie the current Authentication Token. You can certainly use the trusty old HttpClient directly, however using IApiClient provides a few benefits including: Support for Get, Post, Put, Patch, & Delete Automatic Retry for: Internal Server Error Service Timeout Service Unavailable Bad Gateway Gateway Timeout Control over when to dispose the base HttpClient Get helper headers that you can log from your API to track which device your user is using, which verion of the app, and which app, etc, while also being able to easily override or customize the headers you want. Configuring the ApiClient \u00b6 public class MyApiClient : ApiClient { private IPushManager _pushManager { get ; } private IUser _user { get ; } protected override Uri BaseAddress => new Uri ( ConfigurationManager . AppSettings [ \"BackendApi\" ]); public MyApiClient ( IUser user , IPushManager pushManager , ILogger logger , IAppInfo appInfo , IDeviceInfo deviceInfo ) : base ( logger , appInfo , deviceInfo ) { _pushManager = pushManager ; _user = user ; } protected override Task < string > GetTokenAsync () { return Task . FromResult ( _user . AccessToken ); } protected override string GetInstallId () { return _pushManager . CurrentRegistrationToken ; } } Additional Configurations \u00b6 The ApiClient has a few additional overridable methods that can allow you to further tailor the ApiClient to your specific needs. Default Headers \u00b6 You can configure the default headers that will be sent by overriding SetDefaultHeaders. protected override void SetDefaultHeaders ( HttpClient client ) { client . DefaultRequestHeaders . Accept . Add ( new MediaTypeWithQualityHeaderValue ( \"application/json\" )); client . DefaultRequestHeaders . CacheControl = new CacheControlHeaderValue { NoCache = true }; var appName = Regex . Replace ( AppInfo . Name , @\"\\s\" , string . Empty ). ToASCII (); var agentHeader = ProductHeaderValue . Parse ( $\"{appName}/{AppInfo.VersionString.ToASCII()}\" ); client . DefaultRequestHeaders . UserAgent . Add ( new ProductInfoHeaderValue ( agentHeader )); client . DefaultRequestHeaders . Add ( \"X-MobileAppVer\" , AppInfo . VersionString . ToASCII ()); client . DefaultRequestHeaders . Add ( \"X-DeviceModel\" , DeviceInfo . Model . ToASCII ()); client . DefaultRequestHeaders . Add ( \"X-DeviceManufacturer\" , DeviceInfo . Manufacturer . ToASCII ()); client . DefaultRequestHeaders . Add ( \"X-DeviceName\" , DeviceInfo . Name . ToASCII ()); client . DefaultRequestHeaders . Add ( \"X-DevicePlatform\" , $\"{DeviceInfo.Platform}\" ); client . DefaultRequestHeaders . Add ( \"X-DeviceIdiom\" , $\"{DeviceInfo.Idiom}\" ); if ( TryGetInstallId ( out var installId )) { client . DefaultRequestHeaders . Add ( \"X-ClientId\" , installId ); } } Customizing the Message Handlers \u00b6 You can optionally provide custom a HttpMessageHandler for the HttpClient. Note that you should be intentional on setting the innerHandler to the one passed in otherwise authentication may not work properly. protected override HttpMessageHandler CreateHandler ( HttpMessageHandler innerHandler ) => new MyCustomHandler ( innerHandler ); Customizing the Authentication Header \u00b6 There are two ways to configure the Authentication Header. If your authentication relies on using the standard Authentication Header, you can set the AuthenticationScheme in the constructor. public class MyApiClient : ApiClient { public MyApiClient ( ILogger logger , IAppInfo appInfo , IDeviceInfo deviceInfo ) : base ( logger , appInfo , deviceInfo ) { AuthenticationScheme = \"Basic\" ; } } Note By default the ApiClient uses a Bearer Authentication Scheme. In the event that setting the Authentication Scheme is not enough and you actually need a custom header value you should override the SetAuthenticationHeader method: protected override void SetAuthenticationHeader ( HttpRequestMessage request , string token ) { request . Headers . Add ( \"X-MyAuthHeader\" , token ); } Using the ApiClient \u00b6 public class FooService { private IApiClient ApiClient { get ; } [AllowAnnonymous] public async Task < bool > GetStatus () { var result = await ApiClient . GetAsync ( \"api/status\" ); return result . IsSuccessStatusCode ; } public async Task DoFoo ( SomeModel model ) { await ApiClient . PostAsync ( \"api/doFoo\" , model ); } public async Task < HttpResponseMessage > DoBar () { // Dispose HttpClient on each request with ability to reuse the ApiClient using ( ApiClient ) { return await ApiClient . GetAsync ( \"api/doBar\" ); } } } Additional Headers \u00b6 Out of the box the ApiClient utilizes IAppInfo and IDeviceInfo from Xamarin.Essentials.Interfaces. These are used in combination with some optional configurations in your ApiClient to add useful headers that can collect metadata about your users. Header Sample Value User-Agent AwesomeApp/2.0.4 X-MobileAppVer 2.0.4 X-DeviceModel iPhone10,6 X-DeviceManufacturer Apple X-DeviceName Dan's iPhone X-DevicePlatform iOS X-DeviceIdiom Phone X-ClientId {your install Id} Note If you do not want to use IAppInfo and IDeviceInfo to add metadata, you should simply inherit from ApiClientBase to simplify your implementation.","title":"ApiClient"},{"location":"http/#apmobiletoolkithttp","text":"The Http package includes a lightweight API Client that makes integrating with a custom backend a breeze. You simply need to provide the base options for where the API Client should send it's requests to along with a callback handler to provie the current Authentication Token. You can certainly use the trusty old HttpClient directly, however using IApiClient provides a few benefits including: Support for Get, Post, Put, Patch, & Delete Automatic Retry for: Internal Server Error Service Timeout Service Unavailable Bad Gateway Gateway Timeout Control over when to dispose the base HttpClient Get helper headers that you can log from your API to track which device your user is using, which verion of the app, and which app, etc, while also being able to easily override or customize the headers you want.","title":"AP.MobileToolkit.Http"},{"location":"http/#configuring-the-apiclient","text":"public class MyApiClient : ApiClient { private IPushManager _pushManager { get ; } private IUser _user { get ; } protected override Uri BaseAddress => new Uri ( ConfigurationManager . AppSettings [ \"BackendApi\" ]); public MyApiClient ( IUser user , IPushManager pushManager , ILogger logger , IAppInfo appInfo , IDeviceInfo deviceInfo ) : base ( logger , appInfo , deviceInfo ) { _pushManager = pushManager ; _user = user ; } protected override Task < string > GetTokenAsync () { return Task . FromResult ( _user . AccessToken ); } protected override string GetInstallId () { return _pushManager . CurrentRegistrationToken ; } }","title":"Configuring the ApiClient"},{"location":"http/#additional-configurations","text":"The ApiClient has a few additional overridable methods that can allow you to further tailor the ApiClient to your specific needs.","title":"Additional Configurations"},{"location":"http/#default-headers","text":"You can configure the default headers that will be sent by overriding SetDefaultHeaders. protected override void SetDefaultHeaders ( HttpClient client ) { client . DefaultRequestHeaders . Accept . Add ( new MediaTypeWithQualityHeaderValue ( \"application/json\" )); client . DefaultRequestHeaders . CacheControl = new CacheControlHeaderValue { NoCache = true }; var appName = Regex . Replace ( AppInfo . Name , @\"\\s\" , string . Empty ). ToASCII (); var agentHeader = ProductHeaderValue . Parse ( $\"{appName}/{AppInfo.VersionString.ToASCII()}\" ); client . DefaultRequestHeaders . UserAgent . Add ( new ProductInfoHeaderValue ( agentHeader )); client . DefaultRequestHeaders . Add ( \"X-MobileAppVer\" , AppInfo . VersionString . ToASCII ()); client . DefaultRequestHeaders . Add ( \"X-DeviceModel\" , DeviceInfo . Model . ToASCII ()); client . DefaultRequestHeaders . Add ( \"X-DeviceManufacturer\" , DeviceInfo . Manufacturer . ToASCII ()); client . DefaultRequestHeaders . Add ( \"X-DeviceName\" , DeviceInfo . Name . ToASCII ()); client . DefaultRequestHeaders . Add ( \"X-DevicePlatform\" , $\"{DeviceInfo.Platform}\" ); client . DefaultRequestHeaders . Add ( \"X-DeviceIdiom\" , $\"{DeviceInfo.Idiom}\" ); if ( TryGetInstallId ( out var installId )) { client . DefaultRequestHeaders . Add ( \"X-ClientId\" , installId ); } }","title":"Default Headers"},{"location":"http/#customizing-the-message-handlers","text":"You can optionally provide custom a HttpMessageHandler for the HttpClient. Note that you should be intentional on setting the innerHandler to the one passed in otherwise authentication may not work properly. protected override HttpMessageHandler CreateHandler ( HttpMessageHandler innerHandler ) => new MyCustomHandler ( innerHandler );","title":"Customizing the Message Handlers"},{"location":"http/#customizing-the-authentication-header","text":"There are two ways to configure the Authentication Header. If your authentication relies on using the standard Authentication Header, you can set the AuthenticationScheme in the constructor. public class MyApiClient : ApiClient { public MyApiClient ( ILogger logger , IAppInfo appInfo , IDeviceInfo deviceInfo ) : base ( logger , appInfo , deviceInfo ) { AuthenticationScheme = \"Basic\" ; } } Note By default the ApiClient uses a Bearer Authentication Scheme. In the event that setting the Authentication Scheme is not enough and you actually need a custom header value you should override the SetAuthenticationHeader method: protected override void SetAuthenticationHeader ( HttpRequestMessage request , string token ) { request . Headers . Add ( \"X-MyAuthHeader\" , token ); }","title":"Customizing the Authentication Header"},{"location":"http/#using-the-apiclient","text":"public class FooService { private IApiClient ApiClient { get ; } [AllowAnnonymous] public async Task < bool > GetStatus () { var result = await ApiClient . GetAsync ( \"api/status\" ); return result . IsSuccessStatusCode ; } public async Task DoFoo ( SomeModel model ) { await ApiClient . PostAsync ( \"api/doFoo\" , model ); } public async Task < HttpResponseMessage > DoBar () { // Dispose HttpClient on each request with ability to reuse the ApiClient using ( ApiClient ) { return await ApiClient . GetAsync ( \"api/doBar\" ); } } }","title":"Using the ApiClient"},{"location":"http/#additional-headers","text":"Out of the box the ApiClient utilizes IAppInfo and IDeviceInfo from Xamarin.Essentials.Interfaces. These are used in combination with some optional configurations in your ApiClient to add useful headers that can collect metadata about your users. Header Sample Value User-Agent AwesomeApp/2.0.4 X-MobileAppVer 2.0.4 X-DeviceModel iPhone10,6 X-DeviceManufacturer Apple X-DeviceName Dan's iPhone X-DevicePlatform iOS X-DeviceIdiom Phone X-ClientId {your install Id} Note If you do not want to use IAppInfo and IDeviceInfo to add metadata, you should simply inherit from ApiClientBase to simplify your implementation.","title":"Additional Headers"},{"location":"mvvm/","text":"AP.MobileToolkit - Mvvm \u00b6 The Mvvm package is a Platform specific package and me. Currently support is exclusive to Prism.Forms","title":"AP.MobileToolkit - Mvvm"},{"location":"mvvm/#apmobiletoolkit-mvvm","text":"The Mvvm package is a Platform specific package and me. Currently support is exclusive to Prism.Forms","title":"AP.MobileToolkit - Mvvm"},{"location":"resources/","text":"AP.MobileToolkit.Resources \u00b6 The resources package is intended to provide a set of common words or phrases that you may use throughout your app like Ok or Next , etc. Currently these resources are also available in Spanish but we plan on adding additional languages and would gladly take a PR from any native speakers to add or update localizations. Please be sure to use the Multilingual App Toolkit Editor to edit the xlf files when translating. Words & Phrases \u00b6 Account Generally used for a label Add Generally used for a button text Address Generally used for a label An unexpected error '{0}' occurred. Correlation Id: {1} Error Message Template. Requires Error Message and Correlation Id passed in via string.Format. Used by the APBaseViewModel. Back Generally used for a button text Cancel Generally used to dismiss alerts City Generally used for a label Coming Soon Generally used for a title or label Dismiss Generally used for a button text Email Generally used for a label Error Generally used for a window title First Name Generally used for a label Info Generally used for a title or label Last Name Generally used for a label Loading... Generally used for a label with an Activity Indicator Login May be used for a label, title or button text Next Generally used for a button text No Generally used for a button text Ok Generally used for a button text Reply Generally used for a button text State Generally used for a label Success Generally used for a label Tap to add Used for accessibility help text Tap to cancel Used for accessibility help text Tap to dismiss Used for accessibility help text Tap to go back Used for accessibility help text Tap to login Used for accessibility help text Try Again Generally used for a button text Warning Generally used for a window title Whoops Generally used for a window title Yes Generally used for a button text Zip Generally used for a label","title":"Localized Resources"},{"location":"resources/#apmobiletoolkitresources","text":"The resources package is intended to provide a set of common words or phrases that you may use throughout your app like Ok or Next , etc. Currently these resources are also available in Spanish but we plan on adding additional languages and would gladly take a PR from any native speakers to add or update localizations. Please be sure to use the Multilingual App Toolkit Editor to edit the xlf files when translating.","title":"AP.MobileToolkit.Resources"},{"location":"resources/#words-phrases","text":"Account Generally used for a label Add Generally used for a button text Address Generally used for a label An unexpected error '{0}' occurred. Correlation Id: {1} Error Message Template. Requires Error Message and Correlation Id passed in via string.Format. Used by the APBaseViewModel. Back Generally used for a button text Cancel Generally used to dismiss alerts City Generally used for a label Coming Soon Generally used for a title or label Dismiss Generally used for a button text Email Generally used for a label Error Generally used for a window title First Name Generally used for a label Info Generally used for a title or label Last Name Generally used for a label Loading... Generally used for a label with an Activity Indicator Login May be used for a label, title or button text Next Generally used for a button text No Generally used for a button text Ok Generally used for a button text Reply Generally used for a button text State Generally used for a label Success Generally used for a label Tap to add Used for accessibility help text Tap to cancel Used for accessibility help text Tap to dismiss Used for accessibility help text Tap to go back Used for accessibility help text Tap to login Used for accessibility help text Try Again Generally used for a button text Warning Generally used for a window title Whoops Generally used for a window title Yes Generally used for a button text Zip Generally used for a label","title":"Words &amp; Phrases"},{"location":"rxui/","text":"AP.MobileToolkit.RxUI \u00b6 Cron Jobs \u00b6 The RxUI package is a lightweight helper. This provides us an ObservableCron that allows us to create an observable pipe based on a Cron scheduler. ObservableCron . Start ( \"5 * * * *\" ) . InvokeCommand ( SomeCommand ); Prism Support \u00b6 Also included is a the ReactiveUISupportModule. This module utilizes the ILogger from Prism.Plugin.Logging to log exceptions handled by the RxApp.DefaultExceptionHandler. protected override void ConfigureModuleCatalog ( IModuleCatalog moduleCatalog ) { moduleCatalog . AddModule < ReactiveUISupportModule >(); } What does this do? public ReactiveUISupportModule ( ILogger logger ) { Logger = logger ; RxApp . DefaultExceptionHandler = this ; } public void OnError ( Exception error ) { Logger . Report ( error , new Dictionary < string , string > { { \"Source\" , \"Unobserved ReactiveUI Exception 'OnError'\" } }); } public void OnNext ( Exception value ) { Logger . Report ( value , new Dictionary < string , string > { { \"Source\" , \"Unobserved ReactiveUI Exception 'OnNext'\" } }); }","title":"ReactiveUI"},{"location":"rxui/#apmobiletoolkitrxui","text":"","title":"AP.MobileToolkit.RxUI"},{"location":"rxui/#cron-jobs","text":"The RxUI package is a lightweight helper. This provides us an ObservableCron that allows us to create an observable pipe based on a Cron scheduler. ObservableCron . Start ( \"5 * * * *\" ) . InvokeCommand ( SomeCommand );","title":"Cron Jobs"},{"location":"rxui/#prism-support","text":"Also included is a the ReactiveUISupportModule. This module utilizes the ILogger from Prism.Plugin.Logging to log exceptions handled by the RxApp.DefaultExceptionHandler. protected override void ConfigureModuleCatalog ( IModuleCatalog moduleCatalog ) { moduleCatalog . AddModule < ReactiveUISupportModule >(); } What does this do? public ReactiveUISupportModule ( ILogger logger ) { Logger = logger ; RxApp . DefaultExceptionHandler = this ; } public void OnError ( Exception error ) { Logger . Report ( error , new Dictionary < string , string > { { \"Source\" , \"Unobserved ReactiveUI Exception 'OnError'\" } }); } public void OnNext ( Exception value ) { Logger . Report ( value , new Dictionary < string , string > { { \"Source\" , \"Unobserved ReactiveUI Exception 'OnNext'\" } }); }","title":"Prism Support"},{"location":"core/","text":"AP.CrossPlatform.Core \u00b6 The Core Library is meant to be lightweight and provide things that could easily be used for Client or Backend Development, though it is generally more for Client side development. It is not tied to any specific platforms. Additional Resources \u00b6 Collections Http Helpers Localization Validations","title":"About"},{"location":"core/#apcrossplatformcore","text":"The Core Library is meant to be lightweight and provide things that could easily be used for Client or Backend Development, though it is generally more for Client side development. It is not tied to any specific platforms.","title":"AP.CrossPlatform.Core"},{"location":"core/#additional-resources","text":"Collections Http Helpers Localization Validations","title":"Additional Resources"},{"location":"core/collections/","text":"Grouping \u00b6 Want an easy to use Grouping<TKey, TItem> or need a Grouping<TKey, TSubKey, TItem>. Both are included. Observable Collections \u00b6 ObservableDictionary: Just like a normal dictionary but observable ObservableErrorCollection: A custom ObservableRangeCollection of ValidationError's ObservableRangeCollection: Similar to the ObservableCollection except this allows you to add or remove a range of items with a single notification from INotifyCollectionChanged ObservableStack: For those times where you need the functionality of a Stack the ObservableStack lets you do what you need to do while maintaining observability. Additional Resources \u00b6 Validations","title":"Collections"},{"location":"core/collections/#grouping","text":"Want an easy to use Grouping<TKey, TItem> or need a Grouping<TKey, TSubKey, TItem>. Both are included.","title":"Grouping"},{"location":"core/collections/#observable-collections","text":"ObservableDictionary: Just like a normal dictionary but observable ObservableErrorCollection: A custom ObservableRangeCollection of ValidationError's ObservableRangeCollection: Similar to the ObservableCollection except this allows you to add or remove a range of items with a single notification from INotifyCollectionChanged ObservableStack: For those times where you need the functionality of a Stack the ObservableStack lets you do what you need to do while maintaining observability.","title":"Observable Collections"},{"location":"core/collections/#additional-resources","text":"Validations","title":"Additional Resources"},{"location":"core/http/","text":"HttpClient Extensions \u00b6 The HttpClient Extensions provide a number of useful shortcuts for working with your API. GetJObjectAsync: returns the content as a JObject to work with directly. GetAsync<T>: returns a deserialized Json Response PostJsonObjectAsync: sends a post and serializes the provided object to json Adds convienent overloads for Put, Patch, and Delete HttpRequestHeaders Extensions \u00b6 Add(string, object): calls ToString for you JsonContent \u00b6 Perhaps you've gone to create a custom message for the HttpClient before and noticed there is no easy way to send Json. With the Json Content it's a simple as passing in the object you want to serialize. StringExtensions \u00b6 string AddQueryStringParameters(this string uri, object queryObject): This will evaluate your given queryObject and add any properties that have a JsonProperty attribute as query parameters to the given uri.","title":"Http Helpers"},{"location":"core/http/#httpclient-extensions","text":"The HttpClient Extensions provide a number of useful shortcuts for working with your API. GetJObjectAsync: returns the content as a JObject to work with directly. GetAsync<T>: returns a deserialized Json Response PostJsonObjectAsync: sends a post and serializes the provided object to json Adds convienent overloads for Put, Patch, and Delete","title":"HttpClient Extensions"},{"location":"core/http/#httprequestheaders-extensions","text":"Add(string, object): calls ToString for you","title":"HttpRequestHeaders Extensions"},{"location":"core/http/#jsoncontent","text":"Perhaps you've gone to create a custom message for the HttpClient before and noticed there is no easy way to send Json. With the Json Content it's a simple as passing in the object you want to serialize.","title":"JsonContent"},{"location":"core/http/#stringextensions","text":"string AddQueryStringParameters(this string uri, object queryObject): This will evaluate your given queryObject and add any properties that have a JsonProperty attribute as query parameters to the given uri.","title":"StringExtensions"},{"location":"core/localization/","text":"To really understand the power of ILocalize we'll consider for a moment the scenario that you may want to use the localized resources that are part of the Toolkit and your own resources. ILocalize localize = new ResxLocalize (); // Register local resources localize . RegisterManager ( Resources . ResourceManager ); // Register Toolkit resources localize . RegisterManager ( ToolkitResources . ResourceManager ); Now that our Resource Manager's are registered we can easily retrieve a localized value: Title = localize [ \"ViewATitle\" ]; Note The Localization service will iterate through the ResourceManager's that have been registered and provide the value from the first ResourceManager that contains the key. Important The ResxLocalize service is meant to be a singleton. It can technically be accessed by calling ResxLocalize.Current . It is generally recommended that you use a DI Container to register and resolve the service. Localized Culture \u00b6 By default we will use the CultureInfo from the current UI Culture. In the event that you want to override this behavior for instance if you want to make it user selectable you can set the culture and all subsequent requests will use the specified culture. // If you don't want to use the current UI Culture localize . SetCulture ( new CultureInfo ( \"es\" ); Debugging \u00b6 By default if no key is found it will return an empty string. To debug this you may want to set the Debug property when your app is initializing to instead return a debug value: #if DEBUG ResxLocalize . Debug = true ; #endif var localize = new ResxLocalize (); var value = localize [ \"NonExistentKey\" ]; In this example we would expect to get an output of MISSING NonExistentKey . XAML Extensions \u00b6 If you are using a platform specific package like AP.MobileToolkit.Forms you can expect to find a XAML extension that makes use of ILocalize which can be used like: <ContentPage xmlns:ap= \"http://avantipoint.com/mobiletoolkit\" > <Label Text= \"{ap:Localize 'SomeKey'}\" /> </ContentPage>","title":"Localization"},{"location":"core/localization/#localized-culture","text":"By default we will use the CultureInfo from the current UI Culture. In the event that you want to override this behavior for instance if you want to make it user selectable you can set the culture and all subsequent requests will use the specified culture. // If you don't want to use the current UI Culture localize . SetCulture ( new CultureInfo ( \"es\" );","title":"Localized Culture"},{"location":"core/localization/#debugging","text":"By default if no key is found it will return an empty string. To debug this you may want to set the Debug property when your app is initializing to instead return a debug value: #if DEBUG ResxLocalize . Debug = true ; #endif var localize = new ResxLocalize (); var value = localize [ \"NonExistentKey\" ]; In this example we would expect to get an output of MISSING NonExistentKey .","title":"Debugging"},{"location":"core/localization/#xaml-extensions","text":"If you are using a platform specific package like AP.MobileToolkit.Forms you can expect to find a XAML extension that makes use of ILocalize which can be used like: <ContentPage xmlns:ap= \"http://avantipoint.com/mobiletoolkit\" > <Label Text= \"{ap:Localize 'SomeKey'}\" /> </ContentPage>","title":"XAML Extensions"},{"location":"core/validations/","text":"","title":"Getting Started"},{"location":"fonts/","text":"Note Fonts are handled in a separate repository . Currently Font support is targeting Xamarin.Forms and Maui. We are currently planning on adding support for WinUI and Uno Platform. Initializing Fonts \u00b6 Xamarin.Forms \u00b6 Fonts should be registered with the FontRegistry when your application is initialized. While this may be in slightly different locations depending on your app model, this should be before you navigate or otherwise create a view that may use the font. public partial class App : Application { public App () { InitializeComponent (); FontRegistry . RegisterFonts ( FontAwesomeBrands . Font , FontAwesomeRegular . Font , FontAwesomeSolid . Font ); } } Maui \u00b6 public class Startup : IStartup { public void Configure ( IAppHostBuilder appBuilder ) { appBuilder . UseFormsCompatibility () . UseMauiApp < App >() . ConfigureIconFonts ( b => { b . AddFont ( FontAwesomeRegular . Font ) . AddFont ( FontAwesomeSolid . Font ); // OR b . AddFonts ( FontAwesomeRegular . Font , FontAwesomeSolid . Font ); }) . ConfigureFonts ( fonts => { fonts . AddFont ( \"OpenSans-Regular.ttf\" , \"OpenSansRegular\" ); }); } } Using in Prism.Modules \u00b6 In your module there is no reference to the Toolkit in C#, so the compiler is linking it out and it's not available when it comes time to parse the XAML. Therefore in your Prism.Modules you have to reference it somwehere like this: public MyModule () { _ = global :: AP . MobileToolkit . Fonts . Mappings . FontAwesomeSolid . User ; _ = global :: AP . MobileToolkit . Fonts . FontAwesomeSolid . Font ; _ = global :: AP . MobileToolkit . Xaml . IconExtension . IconNameProperty ; } Of course when if would like to use Brands or Regular you have to switch (or add to) FontAwesomeSolid in the example above according to what you want to use. (For Example _ = global::AP.MobileToolkit.Fonts.FontAwesomeBrands.Font;) Additional Resources \u00b6 Font Generator Using Icon Fonts","title":"Getting Started"},{"location":"fonts/#initializing-fonts","text":"","title":"Initializing Fonts"},{"location":"fonts/#xamarinforms","text":"Fonts should be registered with the FontRegistry when your application is initialized. While this may be in slightly different locations depending on your app model, this should be before you navigate or otherwise create a view that may use the font. public partial class App : Application { public App () { InitializeComponent (); FontRegistry . RegisterFonts ( FontAwesomeBrands . Font , FontAwesomeRegular . Font , FontAwesomeSolid . Font ); } }","title":"Xamarin.Forms"},{"location":"fonts/#maui","text":"public class Startup : IStartup { public void Configure ( IAppHostBuilder appBuilder ) { appBuilder . UseFormsCompatibility () . UseMauiApp < App >() . ConfigureIconFonts ( b => { b . AddFont ( FontAwesomeRegular . Font ) . AddFont ( FontAwesomeSolid . Font ); // OR b . AddFonts ( FontAwesomeRegular . Font , FontAwesomeSolid . Font ); }) . ConfigureFonts ( fonts => { fonts . AddFont ( \"OpenSans-Regular.ttf\" , \"OpenSansRegular\" ); }); } }","title":"Maui"},{"location":"fonts/#using-in-prismmodules","text":"In your module there is no reference to the Toolkit in C#, so the compiler is linking it out and it's not available when it comes time to parse the XAML. Therefore in your Prism.Modules you have to reference it somwehere like this: public MyModule () { _ = global :: AP . MobileToolkit . Fonts . Mappings . FontAwesomeSolid . User ; _ = global :: AP . MobileToolkit . Fonts . FontAwesomeSolid . Font ; _ = global :: AP . MobileToolkit . Xaml . IconExtension . IconNameProperty ; } Of course when if would like to use Brands or Regular you have to switch (or add to) FontAwesomeSolid in the example above according to what you want to use. (For Example _ = global::AP.MobileToolkit.Fonts.FontAwesomeBrands.Font;)","title":"Using in Prism.Modules"},{"location":"fonts/#additional-resources","text":"Font Generator Using Icon Fonts","title":"Additional Resources"},{"location":"fonts/generator/","text":"The Font Generator will generate the required code for your custom fonts. Note The Font's PostTable does matter. Note that only version 2 contains the name of the Glyph. As a result any font's using other versions in the PostTable should include a mapping css file. To add a font, create a new project. Typically this will just be a netstandard class library. You do not need any actual code files in the project. Edit the csproj like shown below: <ItemGroup> <AdditionalFiles Include= \"fa-regular-400-ttf\" Alias= \"far\" FontName= \"FontAwesomeRegular\" Version= \"5.13.0\" CssFile= \"fontawesome.min.css\" /> </ItemGroup> The Generator will automatically parse both the Font file and the supplied Css or Codepoints file specified. This will generate the required attributes to enabled Font Embedding, as well as the IFont implementation, a static Mapping class that will let you reference FontAwesomeRegular.User instead of supplying far fa-user . Finally it will generate a second FontAwesomeRegular static class in the AP.MobileToolkit.Fonts namespace that provides information about the generated font as well as an instance of the generated IFont instance that you can use to register with the Font Registry. Warning Ligature based fonts are not supported without either a CSS file or Codepoints file like we use for The Google Material Font library. Additional Resources \u00b6 Getting Started AP.Mobile.Toolkit Fonts for Xamarin.Forms","title":"Font Generation"},{"location":"fonts/generator/#additional-resources","text":"Getting Started AP.Mobile.Toolkit Fonts for Xamarin.Forms","title":"Additional Resources"},{"location":"forms/","text":"The Toolkit consists of a variety of Behaviors, Controls, Converters and other helpers that are specific to building apps with Xamarin.Forms. Note The core AP.MobileToolkit.Forms package does not take any dependencies on either Prism or ReactiveUI and can be used on ANY Xamarin.Forms project.","title":"Toolkit"},{"location":"forms/behaviors/","text":"","title":"Getting Started"},{"location":"forms/controls/markdowntextview/","text":"This easy to use control allows you to set Markdown directly in your UI and will automatically parse and format it. <ContentPage> <ap:MarkdownTextView Markdown= \"{Binding MyMarkdownProperty}\" /> </ContentPage>","title":"MarkdownTextView"},{"location":"forms/controls/menubar/","text":"The MenuBar is a control purpose built for the Menu Builder to make it easier to add menus, typically to the Master of a MasterDetailPage. <MasterDetailPage> <MasterDetailPage.Master> <ContentPage Title= \"Menu\" > <ap:MenuBar MenuOptions= \"{Binding MenuOptions}\" NavigationCommand= \"{Binding NavigationCommand}\" /> </ContentPage> </MasterDetailpage.Master> </MasterDetailPage> Additional Resources \u00b6 Menu Builder","title":"MenuBar"},{"location":"forms/controls/menubar/#additional-resources","text":"Menu Builder","title":"Additional Resources"},{"location":"forms/controls/repeaterview/","text":"Why provide a RepeaterView? After all with BindableLayout in Xamarin.Forms you can now pretty much accomplish the same thing right? Technically yes you can, however the RepeaterView in the Toolkit simplifies the process by providing the ItemsSource and ItemTemplate properties as part of the layout. Additionally it provides a Header property that can be used. <ap:RepeaterView ItemsSource= \"{Binding MyItems}\" ItemTemplate= \"{StaticResource MyDataTemplate}\" > <ap:RepeaterView.Header> <Label Text= \"Example Header\" /> </ap:RepeaterView.Header> </ap:RepeaterView>","title":"RepeaterView"},{"location":"forms/controls/selectorview/","text":"The SelectorView is built ontop of the RepeaterView so it has a similar API with a few additions that make it great for dealing with Models that implement ISelectable from the AP.CrossPlatform.Core. // Note you should implement INotifyPropertyChanged for the properties public class MyItem : ISelectable { public string Name { get ; set ; } public bool IsSelected { get ; set ; } } The SelectorView can be configured to allow you to select only a Single Element or Multiple Elements.","title":"SelectorView"},{"location":"forms/controls/swipecardview/","text":"","title":"SwipeCardView"},{"location":"forms/converters/","text":"","title":"What's Included"},{"location":"forms/converters/booleantocolor/","text":"The BooleanToColorConverter is a great converter for toggling the color on an element based on a boolean value. Note The default colors are Green for true and Red for false . <ContentPage xmlns:ap= \"http://avantipoint.com/mobiletoolkit\" > <ContentPage.Resources> <ResourceDictionary> <ap:BooleanToColorConverter TrueColor= \"Blue\" FalseColor= \"Black\" x:Key= \"boolToColor\" /> </ResourceDictionary> <BoxView Color= \"{Binding IsSomethingTrue, Converter={StaticResource boolToColor}}\" /> </ContentPage.Resources> </ContentPage>","title":"Booleantocolor"},{"location":"forms/fonts/","text":"Using The Fonts \u00b6 You may be asking why use the MobileToolkit for your Icon Fonts? Xamarin.Forms already has a solution for Fonts right? In short, an Icon Font isn't really any different than any other font. If you provide the unicode character and the font family it will just work, and the FontImageSource will work for those fonts. The problem with this approach is that it's largely meaningless and means you're setting both a Text and Font Family property. The MobileToolkit helps you to write code that is easier to read and is ultimately self documenting by taking the unicode character out of the equation and letting you use libraries like Font Awesome the same way you've always used them on the web by just referencing the css classes like fas fa-users . Getting Started \u00b6 Like the rest of the Toolkit we try to make development as easy as possible. Why have to spend extra time writing code comments or ending up with code that's meaningless unless you spend the time to lookup what the unicode character is. <!-- fas fa-users --> <Label Text= \"\\uf0c0\" FontFamily= \"fa-solid-900.ttf\" /> While you could try to specify the unicode character ultimately this just is hard to read, and requires some sort of comment in order for you to come along later an know what icon just got used. This is where the MobileToolkit Fonts comes in to make things easier. After registering your fonts, you can use them anywhere in your app similar to how you might use it on the web like fas fa-users . For those using older versions of the MobileToolkit you may be used to some Xaml Extensions like the following: <Label Text= \"{ap:Icon 'fas fa-users'}\" /> While the XamlExtension isn't going anywhere, we wanted to give people a cleaner approach which we recommend that you migrate to, or start out with if you're brand new to the Toolkit. In version 4 we introduced the FontIcon class to help you like: <Label ap:FontIcon.Icon= \"fas fa-users\" /> <Button ap:FontIcon.Icon= \"fas fa-users\" /> Extending the FontIcon functionality \u00b6 There may be times where you are working with a custom control from a 3rd party vendor such as Syncfusion or Telerik where you may want to extend functionality to work with one of their controls in your app. Since the MobileToolkit cannot handle every single control we do provide a hook for you to be able to pass a delegate to enable support for these additional controls. public partial class App : Application { public App () { FontIcon . RegisterDefaultOnChangedHandler ( FontIconHandler ); } private void FontIconHandler ( BindableObject bindable , string selector , string glyph , string fontFamily ) { switch ( bindable ) { case MyCustomControl mcc : mcc . Text = glyph ; mcc . FontFamily = fontFamily ; break ; case MyOtherCustomControl mocc : mocc . IconImageSource = FontIcon . CreateIconImageSource ( bindable , selector ); } } } Mapping Class \u00b6 The Font Generator will additionally generate a Mapping class. If you are in XAML this is already part of the MobileToolkit namespace. Some people don't want a \"magic string\" that could be subject to typos. The mapping class is designed to help you with this by providing you a compiler friendly class you can reference like: <Label ap:FontIcon.Icon= \"{x:Static ap:FontAwesomeSolid.Users}\" /> Image Source \u00b6 The Mobile Toolkit provides an IconImageSource to make it easy to use Icon Fonts for a whole host of scenarios such as menu bar icons. While you can use the FontIcon class create the icon the same way you would on a Label or Button, may want to just simply set the Image Source directly which you can do either with a more verbose ImageSource syntax or XAML Extension as shown here. <Image Source= {ap:IconImageSource 'fas fa-users', Color= Black, Size= 16} /> <Image> <Image.Source> <IconImageSource Name= \"fas fa-users\" Color= \"Black\" Size= \"16\" /> </Image.Source> </Image> Legacy \u00b6 The Toolkit includes an Icon XAML Extension. This can be used by passing in a string with the font alias and glyph name. For instance you might use far fa-user to show the User icon from Font Awesome Regular. Alternatively you can use the Static Mapping class to strongly type the icons like FontAwesomeRegular.User . <ContentPage xmlns= \"http://xamarin.com/schemas/2014/forms\" xmlns:x= \"http://schemas.microsoft.com/winfx/2009/xaml\" xmlns:ap= \"http://avantipoint.com/mobiletoolkit\" x:Class= \"SampleFonts.MainPage\" > <StackLayout> <Label Text= \"{ap:Icon 'far fa-user'}\" /> <Button Text= \"{ap:Icon 'far fa-user'}\" /> <Image Source= \"{FontImage Glyph={ap:Icon 'far fa-check-circle'}, Color=Blue, Size=60}\" /> <Label Text= \"{ap:Icon {x:Static ap:FontAwesomeRegular.User}}\" /> </StackLayout> </ContentPage> Note While this is considered legacy, the icon extension still works and we currently do not plan on removing it as this would break anyone updating. Additional Resources \u00b6 Getting Started Font Generation","title":"Getting Started"},{"location":"forms/fonts/#using-the-fonts","text":"You may be asking why use the MobileToolkit for your Icon Fonts? Xamarin.Forms already has a solution for Fonts right? In short, an Icon Font isn't really any different than any other font. If you provide the unicode character and the font family it will just work, and the FontImageSource will work for those fonts. The problem with this approach is that it's largely meaningless and means you're setting both a Text and Font Family property. The MobileToolkit helps you to write code that is easier to read and is ultimately self documenting by taking the unicode character out of the equation and letting you use libraries like Font Awesome the same way you've always used them on the web by just referencing the css classes like fas fa-users .","title":"Using The Fonts"},{"location":"forms/fonts/#getting-started","text":"Like the rest of the Toolkit we try to make development as easy as possible. Why have to spend extra time writing code comments or ending up with code that's meaningless unless you spend the time to lookup what the unicode character is. <!-- fas fa-users --> <Label Text= \"\\uf0c0\" FontFamily= \"fa-solid-900.ttf\" /> While you could try to specify the unicode character ultimately this just is hard to read, and requires some sort of comment in order for you to come along later an know what icon just got used. This is where the MobileToolkit Fonts comes in to make things easier. After registering your fonts, you can use them anywhere in your app similar to how you might use it on the web like fas fa-users . For those using older versions of the MobileToolkit you may be used to some Xaml Extensions like the following: <Label Text= \"{ap:Icon 'fas fa-users'}\" /> While the XamlExtension isn't going anywhere, we wanted to give people a cleaner approach which we recommend that you migrate to, or start out with if you're brand new to the Toolkit. In version 4 we introduced the FontIcon class to help you like: <Label ap:FontIcon.Icon= \"fas fa-users\" /> <Button ap:FontIcon.Icon= \"fas fa-users\" />","title":"Getting Started"},{"location":"forms/fonts/#extending-the-fonticon-functionality","text":"There may be times where you are working with a custom control from a 3rd party vendor such as Syncfusion or Telerik where you may want to extend functionality to work with one of their controls in your app. Since the MobileToolkit cannot handle every single control we do provide a hook for you to be able to pass a delegate to enable support for these additional controls. public partial class App : Application { public App () { FontIcon . RegisterDefaultOnChangedHandler ( FontIconHandler ); } private void FontIconHandler ( BindableObject bindable , string selector , string glyph , string fontFamily ) { switch ( bindable ) { case MyCustomControl mcc : mcc . Text = glyph ; mcc . FontFamily = fontFamily ; break ; case MyOtherCustomControl mocc : mocc . IconImageSource = FontIcon . CreateIconImageSource ( bindable , selector ); } } }","title":"Extending the FontIcon functionality"},{"location":"forms/fonts/#mapping-class","text":"The Font Generator will additionally generate a Mapping class. If you are in XAML this is already part of the MobileToolkit namespace. Some people don't want a \"magic string\" that could be subject to typos. The mapping class is designed to help you with this by providing you a compiler friendly class you can reference like: <Label ap:FontIcon.Icon= \"{x:Static ap:FontAwesomeSolid.Users}\" />","title":"Mapping Class"},{"location":"forms/fonts/#image-source","text":"The Mobile Toolkit provides an IconImageSource to make it easy to use Icon Fonts for a whole host of scenarios such as menu bar icons. While you can use the FontIcon class create the icon the same way you would on a Label or Button, may want to just simply set the Image Source directly which you can do either with a more verbose ImageSource syntax or XAML Extension as shown here. <Image Source= {ap:IconImageSource 'fas fa-users', Color= Black, Size= 16} /> <Image> <Image.Source> <IconImageSource Name= \"fas fa-users\" Color= \"Black\" Size= \"16\" /> </Image.Source> </Image>","title":"Image Source"},{"location":"forms/fonts/#legacy","text":"The Toolkit includes an Icon XAML Extension. This can be used by passing in a string with the font alias and glyph name. For instance you might use far fa-user to show the User icon from Font Awesome Regular. Alternatively you can use the Static Mapping class to strongly type the icons like FontAwesomeRegular.User . <ContentPage xmlns= \"http://xamarin.com/schemas/2014/forms\" xmlns:x= \"http://schemas.microsoft.com/winfx/2009/xaml\" xmlns:ap= \"http://avantipoint.com/mobiletoolkit\" x:Class= \"SampleFonts.MainPage\" > <StackLayout> <Label Text= \"{ap:Icon 'far fa-user'}\" /> <Button Text= \"{ap:Icon 'far fa-user'}\" /> <Image Source= \"{FontImage Glyph={ap:Icon 'far fa-check-circle'}, Color=Blue, Size=60}\" /> <Label Text= \"{ap:Icon {x:Static ap:FontAwesomeRegular.User}}\" /> </StackLayout> </ContentPage> Note While this is considered legacy, the icon extension still works and we currently do not plan on removing it as this would break anyone updating.","title":"Legacy"},{"location":"forms/fonts/#additional-resources","text":"Getting Started Font Generation","title":"Additional Resources"},{"location":"forms/menus/","text":"It's a pretty common paradigm that you may have a MasterDetailPage that may need to update with various menu options. The abstractions for the Menu Builder help you do just that along with the MenuBar . Note This could be used either with Prism's INavigationService or Shell Navigation IMenuBuilder builder = new MenuBuilder (); builder . RegisterOption ( new MainMenuOption { Text = \"Home\" , Uri = \"/home\" , Priority = - 1 , // far fa-dashboard Glyph = Mappings . FontAwesomeRegular . Dashboard }); Note If you are using the AP.MobileToolkit.Fonts you only need to provide the Mapping value for the glyph. Otherwise you should use the Unicode value and Font Family. Additional Resources \u00b6 MenuBar","title":"Menus"},{"location":"forms/menus/#additional-resources","text":"MenuBar","title":"Additional Resources"},{"location":"forms/mvvm/dialogviewmodelbase/","text":"The APBaseDialogViewModel implements both IDialogAware and IDestructible. This allows you to write less code and inherits from ReactiveObject so it's ready for Reactive programmming out of the box. public class MyDialog : APBaseDialogViewModel { [Reactive] public string Title { get ; set ; } [Reactive] public string Message { get ; set ; } }","title":"APBaseDialogViewModel"},{"location":"forms/mvvm/viewmodelbase/","text":"CoreServices \u00b6 The APBaseViewModel is built around maintainability. Part of this includes the use a single provider class that contains various services. The benefit of this pattern is that over time as things change you do not have to change every single ViewModel constructor that inherits from the base ViewModel. As such we also recommend that any base ViewModel that you create or that inherits from our base should follow a similar paradigm for maintainability. Note The provider class does not need to be registered witht the container since it is a concrete type. Base Properties \u00b6 Title: The title is set automatically for you. It will attempt to use ILocalize to get the title using the ViewModel Type Name. If it cannot find a value it will remove the ViewModel suffix and Humanize the name. Note that this is set from the GetTitle() method and can be overriden to provide custom behavior. Subtitle: This isn't directly used but is provided for convienence. IsBusy: This uses the protected ObservableToPropertyHelper<bool> _isBusyHelper for the Busy Value. By default the base ViewModel does not set the ObservableToPropertyHelper since we cannot possibly know what will cause your specific ViewModel to enter a \"Busy\" state. This is protected so you can easily set it from your ViewModel's constructor. IsNotBusy: Similar to the IsBusy property this utilizes an ObservableToPropertyHelper under the covers. Since this is the exact inverse of IsBusy this is set for you automatically in the base and cannot be overridden. NavigateCommand: The NavigateCommand makes uses of the underlying HandleNavigateRequest methods and takes a navigation string CallbackPath: This can be useful to set in the ViewModel's initialization when you may need to complete a task and then navigate to a specific uri. Disposables: The Disposables property is a CompositeDisposable to make it easier to dispose of things automatically using the DisposeWith extension. Anything registered with the CompositeDisposable will be disposed for you automatically when IDestructible is called by Prism. You do not need to ever call base.Destory(); in the event you have additional cleanup to do in the Destroy method.","title":"APBaseViewModel"},{"location":"forms/mvvm/viewmodelbase/#coreservices","text":"The APBaseViewModel is built around maintainability. Part of this includes the use a single provider class that contains various services. The benefit of this pattern is that over time as things change you do not have to change every single ViewModel constructor that inherits from the base ViewModel. As such we also recommend that any base ViewModel that you create or that inherits from our base should follow a similar paradigm for maintainability. Note The provider class does not need to be registered witht the container since it is a concrete type.","title":"CoreServices"},{"location":"forms/mvvm/viewmodelbase/#base-properties","text":"Title: The title is set automatically for you. It will attempt to use ILocalize to get the title using the ViewModel Type Name. If it cannot find a value it will remove the ViewModel suffix and Humanize the name. Note that this is set from the GetTitle() method and can be overriden to provide custom behavior. Subtitle: This isn't directly used but is provided for convienence. IsBusy: This uses the protected ObservableToPropertyHelper<bool> _isBusyHelper for the Busy Value. By default the base ViewModel does not set the ObservableToPropertyHelper since we cannot possibly know what will cause your specific ViewModel to enter a \"Busy\" state. This is protected so you can easily set it from your ViewModel's constructor. IsNotBusy: Similar to the IsBusy property this utilizes an ObservableToPropertyHelper under the covers. Since this is the exact inverse of IsBusy this is set for you automatically in the base and cannot be overridden. NavigateCommand: The NavigateCommand makes uses of the underlying HandleNavigateRequest methods and takes a navigation string CallbackPath: This can be useful to set in the ViewModel's initialization when you may need to complete a task and then navigate to a specific uri. Disposables: The Disposables property is a CompositeDisposable to make it easier to dispose of things automatically using the DisposeWith extension. Anything registered with the CompositeDisposable will be disposed for you automatically when IDestructible is called by Prism. You do not need to ever call base.Destory(); in the event you have additional cleanup to do in the Destroy method.","title":"Base Properties"}]}