{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AvantiPoint Mobile Toolkit \u00b6 The AvantiPoint Mobile Toolkit is built for producing Enterprise Quality applications. The Toolkit is broken into smaller chunks that are largely platform independent. Build Status \u00b6 Project Build Status AP.MobileToolkit AP.MobileToolkit.Fonts NuGet \u00b6 You can add the MyGet CI feed to nuget by adding it as a source in Visual Studio: https://www.myget.org/F/apmobiletoolkit/api/v3/index.json Tools \u00b6 Package NuGet MyGet AP.MobileToolkit.FontGenerator Cross Platform \u00b6 Package NuGet MyGet AP.CrossPlatform.Auth AP.CrossPlatform.Core AP.MobileToolkit.AAD AP.MobileToolkit.Http AP.MobileToolkit.Modularity AP.MobileToolkit.Resources AP.MobileToolkit.RxUI Xamarin.Forms \u00b6 Package NuGet MyGet AP.MobileToolkit.Forms AP.MobileToolkit.Forms.Mvvm AP.MobileToolkit.Forms.Fonts AP.MobileToolkit.Forms.Fonts.FontAwesomeFree.Brands AP.MobileToolkit.Forms.Fonts.FontAwesomeFree.Regular AP.MobileToolkit.Forms.Fonts.FontAwesomeFree.Solid","title":"Home"},{"location":"#avantipoint-mobile-toolkit","text":"The AvantiPoint Mobile Toolkit is built for producing Enterprise Quality applications. The Toolkit is broken into smaller chunks that are largely platform independent.","title":"AvantiPoint Mobile Toolkit"},{"location":"#build-status","text":"Project Build Status AP.MobileToolkit AP.MobileToolkit.Fonts","title":"Build Status"},{"location":"#nuget","text":"You can add the MyGet CI feed to nuget by adding it as a source in Visual Studio: https://www.myget.org/F/apmobiletoolkit/api/v3/index.json","title":"NuGet"},{"location":"#tools","text":"Package NuGet MyGet AP.MobileToolkit.FontGenerator","title":"Tools"},{"location":"#cross-platform","text":"Package NuGet MyGet AP.CrossPlatform.Auth AP.CrossPlatform.Core AP.MobileToolkit.AAD AP.MobileToolkit.Http AP.MobileToolkit.Modularity AP.MobileToolkit.Resources AP.MobileToolkit.RxUI","title":"Cross Platform"},{"location":"#xamarinforms","text":"Package NuGet MyGet AP.MobileToolkit.Forms AP.MobileToolkit.Forms.Mvvm AP.MobileToolkit.Forms.Fonts AP.MobileToolkit.Forms.Fonts.FontAwesomeFree.Brands AP.MobileToolkit.Forms.Fonts.FontAwesomeFree.Regular AP.MobileToolkit.Forms.Fonts.FontAwesomeFree.Solid","title":"Xamarin.Forms"},{"location":"aad/","text":"AP.MobileToolkit.AAD \u00b6 The AAD package provides an easy to use wrapper for the MSAL library and works with both Azure Active Directory and Azure Active Directory B2C. Getting Started \u00b6 To start you'll need to implement some options. The fastest way is to use the IB2COptions or IAADOptions. public class B2COptions : IB2COptions { public string Tenant => Secrets . AADTenant ; public string ClientId => Secrets . AADClientId ; public LogLevel ? LogLevel => Microsoft . Identity . Client . LogLevel . Error ; } Now that you've added your options you can create Authentication Service by using the MsalHelper : var authService = MsalHelper . CreateB2C < B2COptions >(); var authResult = await authService . LoginAsync (); if ( authResult . Success ) { // Do Something... } else { // Do Something Else... } Why use the AAD Package \u00b6 If you've looked at the MSAL Docs... they're confusing to say the least. The AAD Package greatly simplifies what you need to do to successfully use MSAL correctly. It is also built with a proper understanding of best practices to minimize authentications against the AD Tenant which can reduce your costs and improve user performance since you're reducing Http calls.","title":"Azure Active Directory"},{"location":"aad/#apmobiletoolkitaad","text":"The AAD package provides an easy to use wrapper for the MSAL library and works with both Azure Active Directory and Azure Active Directory B2C.","title":"AP.MobileToolkit.AAD"},{"location":"aad/#getting-started","text":"To start you'll need to implement some options. The fastest way is to use the IB2COptions or IAADOptions. public class B2COptions : IB2COptions { public string Tenant => Secrets . AADTenant ; public string ClientId => Secrets . AADClientId ; public LogLevel ? LogLevel => Microsoft . Identity . Client . LogLevel . Error ; } Now that you've added your options you can create Authentication Service by using the MsalHelper : var authService = MsalHelper . CreateB2C < B2COptions >(); var authResult = await authService . LoginAsync (); if ( authResult . Success ) { // Do Something... } else { // Do Something Else... }","title":"Getting Started"},{"location":"aad/#why-use-the-aad-package","text":"If you've looked at the MSAL Docs... they're confusing to say the least. The AAD Package greatly simplifies what you need to do to successfully use MSAL correctly. It is also built with a proper understanding of best practices to minimize authentications against the AD Tenant which can reduce your costs and improve user performance since you're reducing Http calls.","title":"Why use the AAD Package"},{"location":"auth/","text":"AP.CrossPlatform.Auth \u00b6 The Auth package is a lightweight Authentication abstraction layer. This includes a reference to Prism.Core and provides some base events that can be used by the Prism EventAggregator. This is largely meant to help when dealing with a JWT and you need to be able to see the claims of your user contained in the JWT. Let's assume you had the following JWT: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwiZ2l2ZW5fbmFt ZSI6IkpvaG4iLCJmYW1pbHlfbmFtZSI6IkRvZSIsIm9pZCI6IjdkOTU5NGUyLTZmMGUtNDI4NS05N DkzLWUyYzRlY2Y4OThlMiIsImVtYWlscyI6WyJqb2huLmRvZUBnbWFpbC5jb20iXSwiaWF0IjoxNT E2MjM5MDIyLCJhdXRoX3RpbWUiOjE1MTYyMzkwMjIsIm5iZiI6MTUxNjIzOTAyMiwibmV3VXNlciI 6ZmFsc2V9.ysgzPbgqvQr4pY-C3PD-wDEI7yd6evWjeGfi8KcvkYQ In the Payload of the JWT we would see the following: { \"sub\" : \"1234567890\" , \"given_name\" : \"John\" , \"family_name\" : \"Doe\" , \"oid\" : \"7d9594e2-6f0e-4285-9493-e2c4ecf898e2\" , \"emails\" : [ \"john.doe@gmail.com\" ], \"iat\" : 1516239022 , \"auth_time\" : 1516239022 , \"nbf\" : 1516239022 , \"newUser\" : false } We can easily parse the JWT and get the user claims provided like: var user = new JwtUser ( jwt ); Name = $ \"{user.FirstName} {user.LastName}\" ; OnBoardUser = user . IsNew ; More Reading \u00b6 For more information be sure to check out the Azure Active Directory support via the MSAL library: MSAL Support","title":"Auth"},{"location":"auth/#apcrossplatformauth","text":"The Auth package is a lightweight Authentication abstraction layer. This includes a reference to Prism.Core and provides some base events that can be used by the Prism EventAggregator. This is largely meant to help when dealing with a JWT and you need to be able to see the claims of your user contained in the JWT. Let's assume you had the following JWT: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwiZ2l2ZW5fbmFt ZSI6IkpvaG4iLCJmYW1pbHlfbmFtZSI6IkRvZSIsIm9pZCI6IjdkOTU5NGUyLTZmMGUtNDI4NS05N DkzLWUyYzRlY2Y4OThlMiIsImVtYWlscyI6WyJqb2huLmRvZUBnbWFpbC5jb20iXSwiaWF0IjoxNT E2MjM5MDIyLCJhdXRoX3RpbWUiOjE1MTYyMzkwMjIsIm5iZiI6MTUxNjIzOTAyMiwibmV3VXNlciI 6ZmFsc2V9.ysgzPbgqvQr4pY-C3PD-wDEI7yd6evWjeGfi8KcvkYQ In the Payload of the JWT we would see the following: { \"sub\" : \"1234567890\" , \"given_name\" : \"John\" , \"family_name\" : \"Doe\" , \"oid\" : \"7d9594e2-6f0e-4285-9493-e2c4ecf898e2\" , \"emails\" : [ \"john.doe@gmail.com\" ], \"iat\" : 1516239022 , \"auth_time\" : 1516239022 , \"nbf\" : 1516239022 , \"newUser\" : false } We can easily parse the JWT and get the user claims provided like: var user = new JwtUser ( jwt ); Name = $ \"{user.FirstName} {user.LastName}\" ; OnBoardUser = user . IsNew ;","title":"AP.CrossPlatform.Auth"},{"location":"auth/#more-reading","text":"For more information be sure to check out the Azure Active Directory support via the MSAL library: MSAL Support","title":"More Reading"},{"location":"http/","text":"AP.MobileToolkit.Http \u00b6 The Http package includes a lightweight API Client that makes integrating with a custom backend a breeze. You simply need to provide the base options for where the API Client should send it's requests to along with a callback handler to provie the current Authentication Token. You can certainly use the trusty old HttpClient directly, however using IApiClient provides a few benefits including: Support for Get, Post, Put, Patch, & Delete Automatic Retry for: Internal Server Error Service Timeout Service Unavailable Bad Gateway Gateway Timeout Control over when to dispose the base HttpClient Get helper headers that you can log from your API to track which device your user is using, which verion of the app, and which app, etc, while also being able to easily override or customize the headers you want. Configuring the ApiClient \u00b6 public class MyApiClient : ApiClient { private IPushManager _pushManager { get ; } private IUser _user { get ; } protected override Uri BaseAddress => new Uri ( ConfigurationManager . AppSettings [ \"BackendApi\" ]); public MyApiClient ( IUser user , IPushManager pushManager , ILogger logger , IAppInfo appInfo , IDeviceInfo deviceInfo ) : base ( logger , appInfo , deviceInfo ) { _pushManager = pushManager ; _user = user ; } protected override Task < string > GetTokenAsync () { return Task . FromResult ( _user . AccessToken ); } protected override string GetInstallId () { return _pushManager . CurrentRegistrationToken ; } } Additional Configurations \u00b6 The ApiClient has a few additional overridable methods that can allow you to further tailor the ApiClient to your specific needs. Default Headers \u00b6 You can configure the default headers that will be sent by overriding SetDefaultHeaders. protected override void SetDefaultHeaders ( HttpClient client ) { client . DefaultRequestHeaders . Accept . Add ( new MediaTypeWithQualityHeaderValue ( \"application/json\" )); client . DefaultRequestHeaders . CacheControl = new CacheControlHeaderValue { NoCache = true }; var appName = Regex . Replace ( AppInfo . Name , @\"\\s\" , string . Empty ). ToASCII (); var agentHeader = ProductHeaderValue . Parse ( $ \"{appName}/{AppInfo.VersionString.ToASCII()}\" ); client . DefaultRequestHeaders . UserAgent . Add ( new ProductInfoHeaderValue ( agentHeader )); client . DefaultRequestHeaders . Add ( \"X-MobileAppVer\" , AppInfo . VersionString . ToASCII ()); client . DefaultRequestHeaders . Add ( \"X-DeviceModel\" , DeviceInfo . Model . ToASCII ()); client . DefaultRequestHeaders . Add ( \"X-DeviceManufacturer\" , DeviceInfo . Manufacturer . ToASCII ()); client . DefaultRequestHeaders . Add ( \"X-DeviceName\" , DeviceInfo . Name . ToASCII ()); client . DefaultRequestHeaders . Add ( \"X-DevicePlatform\" , $ \"{DeviceInfo.Platform}\" ); client . DefaultRequestHeaders . Add ( \"X-DeviceIdiom\" , $ \"{DeviceInfo.Idiom}\" ); if ( TryGetInstallId ( out var installId )) { client . DefaultRequestHeaders . Add ( \"X-ClientId\" , installId ); } } Customizing the Message Handlers \u00b6 You can optionally provide custom a HttpMessageHandler for the HttpClient. Note that you should be intentional on setting the innerHandler to the one passed in otherwise authentication may not work properly. protected override HttpMessageHandler CreateHandler ( HttpMessageHandler innerHandler ) => new MyCustomHandler ( innerHandler ); Customizing the Authentication Header \u00b6 There are two ways to configure the Authentication Header. If your authentication relies on using the standard Authentication Header, you can set the AuthenticationScheme in the constructor. public class MyApiClient : ApiClient { public MyApiClient ( ILogger logger , IAppInfo appInfo , IDeviceInfo deviceInfo ) : base ( logger , appInfo , deviceInfo ) { AuthenticationScheme = \"Basic\" ; } } Note By default the ApiClient uses a Bearer Authentication Scheme. In the event that setting the Authentication Scheme is not enough and you actually need a custom header value you should override the SetAuthenticationHeader method: protected override void SetAuthenticationHeader ( HttpRequestMessage request , string token ) { request . Headers . Add ( \"X-MyAuthHeader\" , token ); } Using the ApiClient \u00b6 public class FooService { private IApiClient ApiClient { get ; } [AllowAnnonymous] public async Task < bool > GetStatus () { var result = await ApiClient . GetAsync ( \"api/status\" ); return result . IsSuccessStatusCode ; } public async Task DoFoo ( SomeModel model ) { await ApiClient . PostAsync ( \"api/doFoo\" , model ); } public async Task < HttpResponseMessage > DoBar () { // Dispose HttpClient on each request with ability to reuse the ApiClient using ( ApiClient ) { return await ApiClient . GetAsync ( \"api/doBar\" ); } } } Additional Headers \u00b6 Out of the box the ApiClient utilizes IAppInfo and IDeviceInfo from Xamarin.Essentials.Interfaces. These are used in combination with some optional configurations in your ApiClient to add useful headers that can collect metadata about your users. Header Sample Value User-Agent AwesomeApp/2.0.4 X-MobileAppVer 2.0.4 X-DeviceModel iPhone10,6 X-DeviceManufacturer Apple X-DeviceName Dan's iPhone X-DevicePlatform iOS X-DeviceIdiom Phone X-ClientId {your install Id} Note If you do not want to use IAppInfo and IDeviceInfo to add metadata, you should simply inherit from ApiClientBase to simplify your implementation.","title":"ApiClient"},{"location":"http/#apmobiletoolkithttp","text":"The Http package includes a lightweight API Client that makes integrating with a custom backend a breeze. You simply need to provide the base options for where the API Client should send it's requests to along with a callback handler to provie the current Authentication Token. You can certainly use the trusty old HttpClient directly, however using IApiClient provides a few benefits including: Support for Get, Post, Put, Patch, & Delete Automatic Retry for: Internal Server Error Service Timeout Service Unavailable Bad Gateway Gateway Timeout Control over when to dispose the base HttpClient Get helper headers that you can log from your API to track which device your user is using, which verion of the app, and which app, etc, while also being able to easily override or customize the headers you want.","title":"AP.MobileToolkit.Http"},{"location":"http/#configuring-the-apiclient","text":"public class MyApiClient : ApiClient { private IPushManager _pushManager { get ; } private IUser _user { get ; } protected override Uri BaseAddress => new Uri ( ConfigurationManager . AppSettings [ \"BackendApi\" ]); public MyApiClient ( IUser user , IPushManager pushManager , ILogger logger , IAppInfo appInfo , IDeviceInfo deviceInfo ) : base ( logger , appInfo , deviceInfo ) { _pushManager = pushManager ; _user = user ; } protected override Task < string > GetTokenAsync () { return Task . FromResult ( _user . AccessToken ); } protected override string GetInstallId () { return _pushManager . CurrentRegistrationToken ; } }","title":"Configuring the ApiClient"},{"location":"http/#additional-configurations","text":"The ApiClient has a few additional overridable methods that can allow you to further tailor the ApiClient to your specific needs.","title":"Additional Configurations"},{"location":"http/#default-headers","text":"You can configure the default headers that will be sent by overriding SetDefaultHeaders. protected override void SetDefaultHeaders ( HttpClient client ) { client . DefaultRequestHeaders . Accept . Add ( new MediaTypeWithQualityHeaderValue ( \"application/json\" )); client . DefaultRequestHeaders . CacheControl = new CacheControlHeaderValue { NoCache = true }; var appName = Regex . Replace ( AppInfo . Name , @\"\\s\" , string . Empty ). ToASCII (); var agentHeader = ProductHeaderValue . Parse ( $ \"{appName}/{AppInfo.VersionString.ToASCII()}\" ); client . DefaultRequestHeaders . UserAgent . Add ( new ProductInfoHeaderValue ( agentHeader )); client . DefaultRequestHeaders . Add ( \"X-MobileAppVer\" , AppInfo . VersionString . ToASCII ()); client . DefaultRequestHeaders . Add ( \"X-DeviceModel\" , DeviceInfo . Model . ToASCII ()); client . DefaultRequestHeaders . Add ( \"X-DeviceManufacturer\" , DeviceInfo . Manufacturer . ToASCII ()); client . DefaultRequestHeaders . Add ( \"X-DeviceName\" , DeviceInfo . Name . ToASCII ()); client . DefaultRequestHeaders . Add ( \"X-DevicePlatform\" , $ \"{DeviceInfo.Platform}\" ); client . DefaultRequestHeaders . Add ( \"X-DeviceIdiom\" , $ \"{DeviceInfo.Idiom}\" ); if ( TryGetInstallId ( out var installId )) { client . DefaultRequestHeaders . Add ( \"X-ClientId\" , installId ); } }","title":"Default Headers"},{"location":"http/#customizing-the-message-handlers","text":"You can optionally provide custom a HttpMessageHandler for the HttpClient. Note that you should be intentional on setting the innerHandler to the one passed in otherwise authentication may not work properly. protected override HttpMessageHandler CreateHandler ( HttpMessageHandler innerHandler ) => new MyCustomHandler ( innerHandler );","title":"Customizing the Message Handlers"},{"location":"http/#customizing-the-authentication-header","text":"There are two ways to configure the Authentication Header. If your authentication relies on using the standard Authentication Header, you can set the AuthenticationScheme in the constructor. public class MyApiClient : ApiClient { public MyApiClient ( ILogger logger , IAppInfo appInfo , IDeviceInfo deviceInfo ) : base ( logger , appInfo , deviceInfo ) { AuthenticationScheme = \"Basic\" ; } } Note By default the ApiClient uses a Bearer Authentication Scheme. In the event that setting the Authentication Scheme is not enough and you actually need a custom header value you should override the SetAuthenticationHeader method: protected override void SetAuthenticationHeader ( HttpRequestMessage request , string token ) { request . Headers . Add ( \"X-MyAuthHeader\" , token ); }","title":"Customizing the Authentication Header"},{"location":"http/#using-the-apiclient","text":"public class FooService { private IApiClient ApiClient { get ; } [AllowAnnonymous] public async Task < bool > GetStatus () { var result = await ApiClient . GetAsync ( \"api/status\" ); return result . IsSuccessStatusCode ; } public async Task DoFoo ( SomeModel model ) { await ApiClient . PostAsync ( \"api/doFoo\" , model ); } public async Task < HttpResponseMessage > DoBar () { // Dispose HttpClient on each request with ability to reuse the ApiClient using ( ApiClient ) { return await ApiClient . GetAsync ( \"api/doBar\" ); } } }","title":"Using the ApiClient"},{"location":"http/#additional-headers","text":"Out of the box the ApiClient utilizes IAppInfo and IDeviceInfo from Xamarin.Essentials.Interfaces. These are used in combination with some optional configurations in your ApiClient to add useful headers that can collect metadata about your users. Header Sample Value User-Agent AwesomeApp/2.0.4 X-MobileAppVer 2.0.4 X-DeviceModel iPhone10,6 X-DeviceManufacturer Apple X-DeviceName Dan's iPhone X-DevicePlatform iOS X-DeviceIdiom Phone X-ClientId {your install Id} Note If you do not want to use IAppInfo and IDeviceInfo to add metadata, you should simply inherit from ApiClientBase to simplify your implementation.","title":"Additional Headers"},{"location":"mvvm/","text":"AP.MobileToolkit - Mvvm \u00b6 The Mvvm package is a Platform specific package and me. Currently support is exclusive to Prism.Forms","title":"AP.MobileToolkit - Mvvm"},{"location":"mvvm/#apmobiletoolkit-mvvm","text":"The Mvvm package is a Platform specific package and me. Currently support is exclusive to Prism.Forms","title":"AP.MobileToolkit - Mvvm"},{"location":"resources/","text":"AP.MobileToolkit.Resources \u00b6 The resources package is intended to provide a set of common words or phrases that you may use throughout your app like Ok or Next , etc. Currently these resources are also available in Spanish but we plan on adding additional languages and would gladly take a PR from any native speakers to add or update localizations. Please be sure to use the Multilingual App Toolkit Editor to edit the xlf files when translating. Words & Phrases \u00b6 Account Generally used for a label Add Generally used for a button text Address Generally used for a label An unexpected error '{0}' occurred. Correlation Id: {1} Error Message Template. Requires Error Message and Correlation Id passed in via string.Format. Used by the APBaseViewModel. Back Generally used for a button text Cancel Generally used to dismiss alerts City Generally used for a label Coming Soon Generally used for a title or label Dismiss Generally used for a button text Email Generally used for a label Error Generally used for a window title First Name Generally used for a label Info Generally used for a title or label Last Name Generally used for a label Loading... Generally used for a label with an Activity Indicator Login May be used for a label, title or button text Next Generally used for a button text No Generally used for a button text Ok Generally used for a button text Reply Generally used for a button text State Generally used for a label Success Generally used for a label Tap to add Used for accessibility help text Tap to cancel Used for accessibility help text Tap to dismiss Used for accessibility help text Tap to go back Used for accessibility help text Tap to login Used for accessibility help text Try Again Generally used for a button text Warning Generally used for a window title Whoops Generally used for a window title Yes Generally used for a button text Zip Generally used for a label","title":"Localized Resources"},{"location":"resources/#apmobiletoolkitresources","text":"The resources package is intended to provide a set of common words or phrases that you may use throughout your app like Ok or Next , etc. Currently these resources are also available in Spanish but we plan on adding additional languages and would gladly take a PR from any native speakers to add or update localizations. Please be sure to use the Multilingual App Toolkit Editor to edit the xlf files when translating.","title":"AP.MobileToolkit.Resources"},{"location":"resources/#words-phrases","text":"Account Generally used for a label Add Generally used for a button text Address Generally used for a label An unexpected error '{0}' occurred. Correlation Id: {1} Error Message Template. Requires Error Message and Correlation Id passed in via string.Format. Used by the APBaseViewModel. Back Generally used for a button text Cancel Generally used to dismiss alerts City Generally used for a label Coming Soon Generally used for a title or label Dismiss Generally used for a button text Email Generally used for a label Error Generally used for a window title First Name Generally used for a label Info Generally used for a title or label Last Name Generally used for a label Loading... Generally used for a label with an Activity Indicator Login May be used for a label, title or button text Next Generally used for a button text No Generally used for a button text Ok Generally used for a button text Reply Generally used for a button text State Generally used for a label Success Generally used for a label Tap to add Used for accessibility help text Tap to cancel Used for accessibility help text Tap to dismiss Used for accessibility help text Tap to go back Used for accessibility help text Tap to login Used for accessibility help text Try Again Generally used for a button text Warning Generally used for a window title Whoops Generally used for a window title Yes Generally used for a button text Zip Generally used for a label","title":"Words &amp; Phrases"},{"location":"rxui/","text":"AP.MobileToolkit.RxUI \u00b6 Cron Jobs \u00b6 The RxUI package is a lightweight helper. This provides us an ObservableCron that allows us to create an observable pipe based on a Cron scheduler. ObservableCron . Start ( \"5 * * * *\" ) . InvokeCommand ( SomeCommand ); Prism Support \u00b6 Also included is a the ReactiveUISupportModule. This module utilizes the ILogger from Prism.Plugin.Logging to log exceptions handled by the RxApp.DefaultExceptionHandler. protected override void ConfigureModuleCatalog ( IModuleCatalog moduleCatalog ) { moduleCatalog . AddModule < ReactiveUISupportModule >(); } What does this do? public ReactiveUISupportModule ( ILogger logger ) { Logger = logger ; RxApp . DefaultExceptionHandler = this ; } public void OnError ( Exception error ) { Logger . Report ( error , new Dictionary < string , string > { { \"Source\" , \"Unobserved ReactiveUI Exception 'OnError'\" } }); } public void OnNext ( Exception value ) { Logger . Report ( value , new Dictionary < string , string > { { \"Source\" , \"Unobserved ReactiveUI Exception 'OnNext'\" } }); }","title":"ReactiveUI"},{"location":"rxui/#apmobiletoolkitrxui","text":"","title":"AP.MobileToolkit.RxUI"},{"location":"rxui/#cron-jobs","text":"The RxUI package is a lightweight helper. This provides us an ObservableCron that allows us to create an observable pipe based on a Cron scheduler. ObservableCron . Start ( \"5 * * * *\" ) . InvokeCommand ( SomeCommand );","title":"Cron Jobs"},{"location":"rxui/#prism-support","text":"Also included is a the ReactiveUISupportModule. This module utilizes the ILogger from Prism.Plugin.Logging to log exceptions handled by the RxApp.DefaultExceptionHandler. protected override void ConfigureModuleCatalog ( IModuleCatalog moduleCatalog ) { moduleCatalog . AddModule < ReactiveUISupportModule >(); } What does this do? public ReactiveUISupportModule ( ILogger logger ) { Logger = logger ; RxApp . DefaultExceptionHandler = this ; } public void OnError ( Exception error ) { Logger . Report ( error , new Dictionary < string , string > { { \"Source\" , \"Unobserved ReactiveUI Exception 'OnError'\" } }); } public void OnNext ( Exception value ) { Logger . Report ( value , new Dictionary < string , string > { { \"Source\" , \"Unobserved ReactiveUI Exception 'OnNext'\" } }); }","title":"Prism Support"},{"location":"core/","text":"AP.CrossPlatform.Core \u00b6 The Core Library is meant to be lightweight and provide things that could easily be used for Client or Backend Development, though it is generally more for Client side development. It is not tied to any specific platforms. Additional Resources \u00b6 Collections Http Helpers Localization Validations","title":"About"},{"location":"core/#apcrossplatformcore","text":"The Core Library is meant to be lightweight and provide things that could easily be used for Client or Backend Development, though it is generally more for Client side development. It is not tied to any specific platforms.","title":"AP.CrossPlatform.Core"},{"location":"core/#additional-resources","text":"Collections Http Helpers Localization Validations","title":"Additional Resources"},{"location":"core/collections/","text":"Grouping \u00b6 Want an easy to use Grouping<TKey, TItem> or need a Grouping<TKey, TSubKey, TItem>. Both are included. Observable Collections \u00b6 ObservableDictionary: Just like a normal dictionary but observable ObservableErrorCollection: A custom ObservableRangeCollection of ValidationError's ObservableRangeCollection: Similar to the ObservableCollection except this allows you to add or remove a range of items with a single notification from INotifyCollectionChanged ObservableStack: For those times where you need the functionality of a Stack the ObservableStack lets you do what you need to do while maintaining observability. Additional Resources \u00b6 Validations","title":"Collections"},{"location":"core/collections/#grouping","text":"Want an easy to use Grouping<TKey, TItem> or need a Grouping<TKey, TSubKey, TItem>. Both are included.","title":"Grouping"},{"location":"core/collections/#observable-collections","text":"ObservableDictionary: Just like a normal dictionary but observable ObservableErrorCollection: A custom ObservableRangeCollection of ValidationError's ObservableRangeCollection: Similar to the ObservableCollection except this allows you to add or remove a range of items with a single notification from INotifyCollectionChanged ObservableStack: For those times where you need the functionality of a Stack the ObservableStack lets you do what you need to do while maintaining observability.","title":"Observable Collections"},{"location":"core/collections/#additional-resources","text":"Validations","title":"Additional Resources"},{"location":"core/http/","text":"HttpClient Extensions \u00b6 The HttpClient Extensions provide a number of useful shortcuts for working with your API. GetJObjectAsync: returns the content as a JObject to work with directly. GetAsync<T>: returns a deserialized Json Response PostJsonObjectAsync: sends a post and serializes the provided object to json Adds convienent overloads for Put, Patch, and Delete HttpRequestHeaders Extensions \u00b6 Add(string, object): calls ToString for you JsonContent \u00b6 Perhaps you've gone to create a custom message for the HttpClient before and noticed there is no easy way to send Json. With the Json Content it's a simple as passing in the object you want to serialize. StringExtensions \u00b6 string AddQueryStringParameters(this string uri, object queryObject): This will evaluate your given queryObject and add any properties that have a JsonProperty attribute as query parameters to the given uri.","title":"Http Helpers"},{"location":"core/http/#httpclient-extensions","text":"The HttpClient Extensions provide a number of useful shortcuts for working with your API. GetJObjectAsync: returns the content as a JObject to work with directly. GetAsync<T>: returns a deserialized Json Response PostJsonObjectAsync: sends a post and serializes the provided object to json Adds convienent overloads for Put, Patch, and Delete","title":"HttpClient Extensions"},{"location":"core/http/#httprequestheaders-extensions","text":"Add(string, object): calls ToString for you","title":"HttpRequestHeaders Extensions"},{"location":"core/http/#jsoncontent","text":"Perhaps you've gone to create a custom message for the HttpClient before and noticed there is no easy way to send Json. With the Json Content it's a simple as passing in the object you want to serialize.","title":"JsonContent"},{"location":"core/http/#stringextensions","text":"string AddQueryStringParameters(this string uri, object queryObject): This will evaluate your given queryObject and add any properties that have a JsonProperty attribute as query parameters to the given uri.","title":"StringExtensions"},{"location":"core/localization/","text":"To really understand the power of ILocalize we'll consider for a moment the scenario that you may want to use the localized resources that are part of the Toolkit and your own resources. ILocalize localize = new ResxLocalize (); // Register local resources localize . RegisterManager ( Resources . ResourceManager ); // Register Toolkit resources localize . RegisterManager ( ToolkitResources . ResourceManager ); Now that our Resource Manager's are registered we can easily retrieve a localized value: Title = localize [ \"ViewATitle\" ]; Note The Localization service will iterate through the ResourceManager's that have been registered and provide the value from the first ResourceManager that contains the key. Important The ResxLocalize service is meant to be a singleton. It can technically be accessed by calling ResxLocalize.Current . It is generally recommended that you use a DI Container to register and resolve the service. Localized Culture \u00b6 By default we will use the CultureInfo from the current UI Culture. In the event that you want to override this behavior for instance if you want to make it user selectable you can set the culture and all subsequent requests will use the specified culture. // If you don't want to use the current UI Culture localize . SetCulture ( new CultureInfo ( \"es\" ); Debugging \u00b6 By default if no key is found it will return an empty string. To debug this you may want to set the Debug property when your app is initializing to instead return a debug value: #if DEBUG ResxLocalize . Debug = true ; #endif var localize = new ResxLocalize (); var value = localize [ \"NonExistentKey\" ]; In this example we would expect to get an output of MISSING NonExistentKey . XAML Extensions \u00b6 If you are using a platform specific package like AP.MobileToolkit.Forms you can expect to find a XAML extension that makes use of ILocalize which can be used like: <ContentPage xmlns:ap= \"http://avantipoint.com/mobiletoolkit\" > <Label Text= \"{ap:Localize 'SomeKey'}\" /> </ContentPage>","title":"Localization"},{"location":"core/localization/#localized-culture","text":"By default we will use the CultureInfo from the current UI Culture. In the event that you want to override this behavior for instance if you want to make it user selectable you can set the culture and all subsequent requests will use the specified culture. // If you don't want to use the current UI Culture localize . SetCulture ( new CultureInfo ( \"es\" );","title":"Localized Culture"},{"location":"core/localization/#debugging","text":"By default if no key is found it will return an empty string. To debug this you may want to set the Debug property when your app is initializing to instead return a debug value: #if DEBUG ResxLocalize . Debug = true ; #endif var localize = new ResxLocalize (); var value = localize [ \"NonExistentKey\" ]; In this example we would expect to get an output of MISSING NonExistentKey .","title":"Debugging"},{"location":"core/localization/#xaml-extensions","text":"If you are using a platform specific package like AP.MobileToolkit.Forms you can expect to find a XAML extension that makes use of ILocalize which can be used like: <ContentPage xmlns:ap= \"http://avantipoint.com/mobiletoolkit\" > <Label Text= \"{ap:Localize 'SomeKey'}\" /> </ContentPage>","title":"XAML Extensions"},{"location":"core/validations/","text":"","title":"Getting Started"},{"location":"fonts/","text":"Note Fonts are handled in a separate repository . Currently Font support is targeting Xamarin.Forms and is planned for WinUI and Uno Platform. Initializing Fonts \u00b6 Fonts should be registered with the FontRegistry when your application is initialized. While this may be in slightly different locations depending on your app model, this should be before you navigate or otherwise create a view that may use the font. public partial class App : Application { public App () { InitializeComponent (); FontRegistry . RegisterFonts ( FontAwesomeBrands . Font , FontAwesomeRegular . Font , FontAwesomeSolid . Font ); } } Additional Resources \u00b6 Font Generator AP.Mobile.Toolkit Fonts for Xamarin.Forms","title":"Getting Started"},{"location":"fonts/#initializing-fonts","text":"Fonts should be registered with the FontRegistry when your application is initialized. While this may be in slightly different locations depending on your app model, this should be before you navigate or otherwise create a view that may use the font. public partial class App : Application { public App () { InitializeComponent (); FontRegistry . RegisterFonts ( FontAwesomeBrands . Font , FontAwesomeRegular . Font , FontAwesomeSolid . Font ); } }","title":"Initializing Fonts"},{"location":"fonts/#additional-resources","text":"Font Generator AP.Mobile.Toolkit Fonts for Xamarin.Forms","title":"Additional Resources"},{"location":"fonts/generator/","text":"The Font Generator will generate the required code for your custom fonts. Note The Font's PostTable does matter. Note that only version 2 contains the name of the Glyph. As a result any font's using other versions in the PostTable should include a mapping css file. To add a font, create a new project. Typically this will just be a netstandard class library, but this could be a multi-targeted project. You should not have any actual code files in the project. Edit the csproj like shown below: <ItemGroup> <EmbeddedFont Include= \"fa-regular-400.ttf\" Alias= \"far\" FontName= \"FontAwesomeRegular\" Version= \"5.13.0\" /> </ItemGroup> We will add an EmbeddedFont with the path to the otf or ttf font file. Be sure to add the value for the Alias. This is what allows us to do something like far fa-user . Add the FontNamme. This will control the class name used for the generated Font Definition and static mapping class. Warning The Google Material Font is not currently supported as this uses ligatures to make up an icon by spelling it out (i.e. GitHub, Microsoft). For this reason there is currently no way for the Font Generator to understand what icons/glyphs actually belong as part of the font or what the proper name of the glyph would be. Additional Resources \u00b6 Getting Started AP.Mobile.Toolkit Fonts for Xamarin.Forms","title":"Font Generation"},{"location":"fonts/generator/#additional-resources","text":"Getting Started AP.Mobile.Toolkit Fonts for Xamarin.Forms","title":"Additional Resources"},{"location":"forms/","text":"The Toolkit consists of a variety of Behaviors, Controls, Converters and other helpers that are specific to building apps with Xamarin.Forms. Note The core AP.MobileToolkit.Forms package does not take any dependencies on either Prism or ReactiveUI and can be used on ANY Xamarin.Forms project.","title":"Toolkit"},{"location":"forms/behaviors/","text":"","title":"Getting Started"},{"location":"forms/controls/badgeview/","text":"The BadgeView provides a circular background with text in the center. <ContentPage> <ap:BadgeView Text= \"12\" BadgeColor= \"Blue\" /> </ContentPage>","title":"BadgeView"},{"location":"forms/controls/datepickercell/","text":"<DatePickerCell Label= \"Date of Birth\" SelectedDate= \"{Binding DoB}\" Format= \"dd/MM/yyyy\" /> Note By default the DatePickerCell will use the American date format MMMM dd, yyyy","title":"DatePickerCell"},{"location":"forms/controls/gravatarimagesource/","text":"The GravatarImageSource is meant to be an easy to use ImageSource that you can use to easily get the Gravatar Image for any email address. <ContentPage> <Image> <Image.Source> <ap:GravatarImageSource Email= \"{Binding Email}\" Size= \"40\" Default= \"Retro\" /> </Image.Source> </Image> </ContentPage> Note The GravatarImageSource defaults to a default size of 20 and default gravatar of a MysteryPerson. There is additionally a XAML extension to make it's use even easier <ContentPage> <Image Source= \"{ap:GravatarImageSource Email={Binding Email}}\" /> </ContentPage>","title":"GravatarImageSource"},{"location":"forms/controls/imageentry/","text":"","title":"ImageEntry"},{"location":"forms/controls/markdowntextview/","text":"This easy to use control allows you to set Markdown directly in your UI and will automatically parse and format it. <ContentPage> <ap:MarkdownTextView Markdown= \"{Binding MyMarkdownProperty}\" /> </ContentPage>","title":"MarkdownTextView"},{"location":"forms/controls/menubar/","text":"The MenuBar is a control purpose built for the Menu Builder to make it easier to add menus, typically to the Master of a MasterDetailPage. <MasterDetailPage> <MasterDetailPage.Master> <ContentPage Title= \"Menu\" > <ap:MenuBar MenuOptions= \"{Binding MenuOptions}\" NavigationCommand= \"{Binding NavigationCommand}\" /> </ContentPage> </MasterDetailpage.Master> </MasterDetailPage> Additional Resources \u00b6 Menu Builder","title":"MenuBar"},{"location":"forms/controls/menubar/#additional-resources","text":"Menu Builder","title":"Additional Resources"},{"location":"forms/controls/repeaterview/","text":"Why provide a RepeaterView? After all with BindableLayout in Xamarin.Forms you can now pretty much accomplish the same thing right? Technically yes you can, however the RepeaterView in the Toolkit simplifies the process by providing the ItemsSource and ItemTemplate properties as part of the layout. Additionally it provides a Header property that can be used. <ap:RepeaterView ItemsSource= \"{Binding MyItems}\" ItemTemplate= \"{StaticResource MyDataTemplate}\" > <ap:RepeaterView.Header> <Label Text= \"Example Header\" /> </ap:RepeaterView.Header> </ap:RepeaterView>","title":"RepeaterView"},{"location":"forms/controls/selectorview/","text":"The SelectorView is built ontop of the RepeaterView so it has a similar API with a few additions that make it great for dealing with Models that implement ISelectable from the AP.CrossPlatform.Core. // Note you should implement INotifyPropertyChanged for the properties public class MyItem : ISelectable { public string Name { get ; set ; } public bool IsSelected { get ; set ; } } The SelectorView can be configured to allow you to select only a Single Element or Multiple Elements.","title":"SelectorView"},{"location":"forms/controls/swipecardview/","text":"","title":"SwipeCardView"},{"location":"forms/converters/","text":"","title":"What's Included"},{"location":"forms/converters/booleantocolor/","text":"The BooleanToColorConverter is a great converter for toggling the color on an element based on a boolean value. Note The default colors are Green for true and Red for false . <ContentPage xmlns:ap= \"http://avantipoint.com/mobiletoolkit\" > <ContentPage.Resources> <ResourceDictionary> <ap:BooleanToColorConverter TrueColor= \"Blue\" FalseColor= \"Black\" x:Key= \"boolToColor\" /> </ResourceDictionary> <BoxView Color= \"{Binding IsSomethingTrue, Converter={StaticResource boolToColor}}\" /> </ContentPage.Resources> </ContentPage>","title":"Booleantocolor"},{"location":"forms/fonts/","text":"The Toolkit includes an Icon XAML Extension. This can be used by passing in a string with the font alias and glyph name. For instance you might use far fa-user to show the User icon from Font Awesome Regular. Alternatively you can use the Static Mapping class to strongly type the icons like FontAwesomeRegular.User . <ContentPage xmlns= \"http://xamarin.com/schemas/2014/forms\" xmlns:x= \"http://schemas.microsoft.com/winfx/2009/xaml\" xmlns:ap= \"http://avantipoint.com/mobiletoolkit\" x:Class= \"SampleFonts.MainPage\" > <StackLayout> <Label Text= \"{ap:Icon 'far fa-user'}\" /> <Button Text= \"{ap:Icon 'far fa-user'}\" /> <Image Source= \"{FontImage Glyph={ap:Icon 'far fa-check-circle'}, Color=Blue, Size=60}\" /> <Label Text= \"{ap:Icon {x:Static ap:FontAwesomeRegular.User}}\" /> </StackLayout> </ContentPage> Additional Resources \u00b6 Getting Started Font Generation","title":"Getting Started"},{"location":"forms/fonts/#additional-resources","text":"Getting Started Font Generation","title":"Additional Resources"},{"location":"forms/menus/","text":"It's a pretty common paradigm that you may have a MasterDetailPage that may need to update with various menu options. The abstractions for the Menu Builder help you do just that along with the MenuBar . Note This could be used either with Prism's INavigationService or Shell Navigation IMenuBuilder builder = new MenuBuilder (); builder . RegisterOption ( new MainMenuOption { Text = \"Home\" , Uri = \"/home\" , Priority = - 1 , // far fa-dashboard Glyph = Mappings . FontAwesomeRegular . Dashboard }); Note If you are using the AP.MobileToolkit.Fonts you only need to provide the Mapping value for the glyph. Otherwise you should use the Unicode value and Font Family. Additional Resources \u00b6 MenuBar","title":"Menus"},{"location":"forms/menus/#additional-resources","text":"MenuBar","title":"Additional Resources"},{"location":"forms/mvvm/dialogviewmodelbase/","text":"The APBaseDialogViewModel implements both IDialogAware and IDestructible. This allows you to write less code and inherits from ReactiveObject so it's ready for Reactive programmming out of the box. public class MyDialog : APBaseDialogViewModel { [Reactive] public string Title { get ; set ; } [Reactive] public string Message { get ; set ; } }","title":"APBaseDialogViewModel"},{"location":"forms/mvvm/viewmodelbase/","text":"CoreServices \u00b6 The APBaseViewModel is built around maintainability. Part of this includes the use a single provider class that contains various services. The benefit of this pattern is that over time as things change you do not have to change every single ViewModel constructor that inherits from the base ViewModel. As such we also recommend that any base ViewModel that you create or that inherits from our base should follow a similar paradigm for maintainability. Note The provider class does not need to be registered witht the container since it is a concrete type. Base Properties \u00b6 Title: The title is set automatically for you. It will attempt to use ILocalize to get the title using the ViewModel Type Name. If it cannot find a value it will remove the ViewModel suffix and Humanize the name. Note that this is set from the GetTitle() method and can be overriden to provide custom behavior. Subtitle: This isn't directly used but is provided for convienence. IsBusy: This uses the protected ObservableToPropertyHelper<bool> _isBusyHelper for the Busy Value. By default the base ViewModel does not set the ObservableToPropertyHelper since we cannot possibly know what will cause your specific ViewModel to enter a \"Busy\" state. This is protected so you can easily set it from your ViewModel's constructor. IsNotBusy: Similar to the IsBusy property this utilizes an ObservableToPropertyHelper under the covers. Since this is the exact inverse of IsBusy this is set for you automatically in the base and cannot be overridden. NavigateCommand: The NavigateCommand makes uses of the underlying HandleNavigateRequest methods and takes a navigation string CallbackPath: This can be useful to set in the ViewModel's initialization when you may need to complete a task and then navigate to a specific uri. Disposables: The Disposables property is a CompositeDisposable to make it easier to dispose of things automatically using the DisposeWith extension. Anything registered with the CompositeDisposable will be disposed for you automatically when IDestructible is called by Prism. You do not need to ever call base.Destory(); in the event you have additional cleanup to do in the Destroy method.","title":"APBaseViewModel"},{"location":"forms/mvvm/viewmodelbase/#coreservices","text":"The APBaseViewModel is built around maintainability. Part of this includes the use a single provider class that contains various services. The benefit of this pattern is that over time as things change you do not have to change every single ViewModel constructor that inherits from the base ViewModel. As such we also recommend that any base ViewModel that you create or that inherits from our base should follow a similar paradigm for maintainability. Note The provider class does not need to be registered witht the container since it is a concrete type.","title":"CoreServices"},{"location":"forms/mvvm/viewmodelbase/#base-properties","text":"Title: The title is set automatically for you. It will attempt to use ILocalize to get the title using the ViewModel Type Name. If it cannot find a value it will remove the ViewModel suffix and Humanize the name. Note that this is set from the GetTitle() method and can be overriden to provide custom behavior. Subtitle: This isn't directly used but is provided for convienence. IsBusy: This uses the protected ObservableToPropertyHelper<bool> _isBusyHelper for the Busy Value. By default the base ViewModel does not set the ObservableToPropertyHelper since we cannot possibly know what will cause your specific ViewModel to enter a \"Busy\" state. This is protected so you can easily set it from your ViewModel's constructor. IsNotBusy: Similar to the IsBusy property this utilizes an ObservableToPropertyHelper under the covers. Since this is the exact inverse of IsBusy this is set for you automatically in the base and cannot be overridden. NavigateCommand: The NavigateCommand makes uses of the underlying HandleNavigateRequest methods and takes a navigation string CallbackPath: This can be useful to set in the ViewModel's initialization when you may need to complete a task and then navigate to a specific uri. Disposables: The Disposables property is a CompositeDisposable to make it easier to dispose of things automatically using the DisposeWith extension. Anything registered with the CompositeDisposable will be disposed for you automatically when IDestructible is called by Prism. You do not need to ever call base.Destory(); in the event you have additional cleanup to do in the Destroy method.","title":"Base Properties"}]}